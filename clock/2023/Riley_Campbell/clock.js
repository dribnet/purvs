const carTargetX = 400;
let globalBrightness = 0.5;

/*
 * use p5.js to draw a clock on a 960x500 canvas
 */
function draw_clock(obj) {

  let hours = obj.hours;
  let twelveHours = hours % 12 || 12;
  let minutes = obj.minutes;
  let seconds = obj.seconds;
  let millis = obj.millis; 
  let alarm = obj.seconds_until_alarm;


  // global brightness to add a day/night effect, where the brightest time is 12pm and the darkest is 12am
  globalBrightness = map(twelveHours, 0, 12, 0.5, 1);
  if(hours > 12 || hours == 0) {
    globalBrightness = map(twelveHours, 0, 12, 1, 0.5);    
  }

  // phase between -1 and 1 second
  let phase = 1;
  if(seconds % 2 == 0) {
    phase = 1;
  } else {
    phase = -1;
  }

  // // alarm (makes the ocean sway when it goes off)
  if(alarm == 0) {
    let roll = map(millis, 0, 1000, -PI/200, PI/200);
    rotate(roll*phase); 
  } 

  // background
  colorMode(HSB, 100);
  background(60, 80, 50*globalBrightness);

  // draw waves in the background
  let wavesX = 15; wavesY = 12;
  let offset = width/50;

  for(let i = 1; i <= wavesX; i++) {

    let offsetPhase = 1;

    for(let j = 1; j <= wavesY; j++) {
        
        if(offsetPhase == 1) {
          offsetPhase = -1;
        } else {
          offsetPhase = 1;
        }

      // draw wave uses phase and offset phase to swap directions smoothly in the animation and offset stops the waves from looking too grid like
      draw_wave(millis, phase*offsetPhase, (i*width/(wavesX+1))+offset*offsetPhase, j*height/(wavesY+1), alarm); 

    }
  }

  // draw road
  colorMode(HSB, 100);
  rectMode(RADIUS);
  strokeWeight(0);
  
  fill(50*globalBrightness);  
  rect(0, height*0.8, carTargetX+30, 50);
  fill(15, 100, 100*globalBrightness);
  rect(0, (height*0.8)-42, carTargetX+30, 2);
  rect(0, (height*0.8)+42, carTargetX+30, 2);

  // draw cars
  drawCars(millis, seconds, minutes);  

  // draw ferry
  drawFerry(millis, seconds, minutes, hours, twelveHours);

}

// Waves

function draw_wave(millis, wavePhase, xPos, yPos, alarm) { // draws a wave at a location (wavePhase controls whether the wave is going up or down)

  colorMode(HSB, 100);

  millisPhaser = map(millis, 0, 1000, -1*wavePhase, 1*wavePhase);
  let horizontalMotion = 5*millisPhaser;

  push();
  
  translate(xPos+horizontalMotion, yPos);
  scale(1);
  if(alarm == 0) {
    scale(2);
  }
  
  noFill();
  strokeWeight(1);
  stroke(60, 80, 70*globalBrightness);

  // wave curve
  beginShape();
  curveVertex(-20, 2*millisPhaser);
  curveVertex(-15, -2*millisPhaser);
  curveVertex(-10, 2*millisPhaser);
  curveVertex(-5, -2*millisPhaser);
  curveVertex(0, 2*millisPhaser);
  curveVertex(5, -2*millisPhaser);
  curveVertex(10, 2*millisPhaser);
  curveVertex(15, -2*millisPhaser);
  curveVertex(20, 2*millisPhaser);
  endShape();

  pop();

}

// Cars

// list of 60 random hues, one for each car. This list was generated by ChatGPT to speed up the process.
const randomHues = [32, 87, 41, 67, 19, 95, 7, 99, 83, 12, 56, 76, 9, 50, 3, 68, 60, 80, 64, 84, 43, 14, 90, 15, 62, 74, 39, 92, 6, 33, 25, 73, 47, 94, 81, 96, 27, 49, 21, 10, 79, 26, 29, 53, 31, 70, 5, 91, 18, 1, 97, 38, 66, 11, 22, 86, 72, 93, 98, 85, 8, 58, 54, 36]
const cars = [];

class Car {
  constructor(number, hue) {
    this.number = number;
    this.hue = hue;
  }
  
  draw(millis, seconds, minutes) {
    const carGap = 60;
    
    let interpolate = map(seconds, 0, 59, 0, carGap) + map(millis, 0, 1000, 0, carGap/60);

    strokeWeight(0);

    push(); 
    translate(carTargetX-(carGap*(this.number-minutes)) + interpolate + 15, height*0.8); 

    // wheels
    fill(0);         
    ellipse(-9, 8, 8);
    ellipse(9, 8, 8);
    ellipse(-9, -8, 8);
    ellipse(9, -8, 8);

    // body
    rectMode(RADIUS);
    fill(this.hue, 70, 70*globalBrightness);
    rect(0, 0, 15, 10);

    // windows
    fill(60, 50, 100*globalBrightness);
    rect(-10, 0, 1, 8);
    rect(5, 0, 3, 8);

    // number (minutes)
    rotate(PI/2);
    fill(100*globalBrightness);
    textSize(12);
    textAlign(CENTER, CENTER);
    text(this.number.toString(), 0, 4);
    pop();
  }

}

function drawCars(millis, seconds, minutes) { // creates cars if none exist, draws them if they have yet to board the ferry (car number >= minutes)

  if(cars.length == 0) {
    for(let i = 1; i <= 60; i++){
      cars.push(new Car(i, randomHues[i]))
    }

    for(let i = 0; i < cars.length; i++){
      (print(cars[i].number));
    }
  }

  for(let i = 0; i < 60; i++) {
    if(cars[i].number > minutes) {
      cars[i].draw(millis, seconds, minutes);
    }
  }

}

function drawFerry(millis, seconds, minutes, hours, twelveHours) {
  ferryX = 400;
  ferryY = height*0.8;
  ferryRot = 0;
  let secondsWithFraction = seconds + (millis / 1000.0);

  // animation sequence at 1 hour mark
  if(minutes == 0 && seconds <= 10) {;
    ferryRot = 0 + (-PI/60 * secondsWithFraction);
    ferryX = 400 + (600/10 * secondsWithFraction);
    ferryY = (height*0.8) - (100/10 * secondsWithFraction);
  }

  if(minutes == 0 && seconds > 10 && seconds <= 20) {;
    ferryRot = 0 + (PI/200 * (secondsWithFraction-11));
    ferryX = -1000 + (1400/10 * (secondsWithFraction-11));
    ferryY = (height*0.4/10 * (secondsWithFraction-11));
  }

  if(minutes == 0 && seconds > 20 && seconds <= 30) {;
    ferryRot = PI/20 - (PI/200 * (secondsWithFraction-21));
    ferryX = 400 + (400/10 * (secondsWithFraction-21));
    ferryY = height*0.4 + (height*0.4/10 * (secondsWithFraction-21));
  }

  if(minutes == 0 && seconds > 30 && seconds <= 40) {;
    ferryRot = 0;
    ferryX = 800 - (400/10 * (secondsWithFraction-31));
    ferryY = height*0.8;
  }

  // graphics for the ferry

  strokeWeight(0);
  colorMode(HSB, 100);

  push(); 
  
  fill(100*globalBrightness);
  translate(ferryX, ferryY);
  rotate(ferryRot);  

  beginShape();  // base shape
  vertex(0, -65);  
  vertex(0, 65);
  vertex(300, 75);
  vertex(350, 45);
  vertex(400, 0);
  vertex(350, -45);
  vertex(300, -75);
  endShape();


  fill(10, 50, 70*globalBrightness);

  beginShape();  // deck (smaller copy of base shape)
  vertex(10, -55);  
  vertex(10, 55);
  vertex(295, 65);
  vertex(340, 40);
  vertex(385, 0);
  vertex(340, -40);
  vertex(295, -65);
  endShape();

  fill(0, 50, 50*globalBrightness);

  beginShape();  // upper level (smaller copy of base shape)
  vertex(120, -45);  
  vertex(120, 45);
  vertex(295, 45);
  vertex(320, 30);
  vertex(340, 0);
  vertex(320, -30);
  vertex(295, -45);
  endShape();

  fill(20*globalBrightness);  // chimneys
  strokeWeight(5)
  stroke(40*globalBrightness);
  ellipse(275, 0, 70);
  ellipse(175, 0, 70);

  let secondsText1 = '0';
  let secondsText2 = '0';
  if(seconds.toString().length > 1) {
    secondsText1 = seconds.toString()[0];
    secondsText2 = seconds.toString()[1];
  }  else {
    secondsText1 = '0';
    secondsText2 = seconds.toString()[0];
  }

  // using alpha to make the seconds numbers in the chimney stacks fade away like smoke
  let sAlpha = map(millis, 0, 800, 80, 0);
  strokeWeight(0); // number (seconds)
  fill(0, 0, 100*globalBrightness, sAlpha);

  // scaling the seconds text over a second to make it look like it's getting closer to the top of the chimney
  let sTextSize = map(millis, 0, 1000, 0, 100);
  textSize(sTextSize);
  textAlign(CENTER, CENTER);
  text(secondsText1, 175, 0);
  text(secondsText2, 275, 0);

  strokeWeight(5); // number (hour)
  stroke(100*globalBrightness);
  fill(100*globalBrightness);

  // this maintains the displayed hour on the boat until after it has left the screen
  let displayedHour = twelveHours.toString();
  if(minutes == 0 && seconds <= 10) {
    displayedHour = (twelveHours-1).toString();
  }

  textSize(72);
  textAlign(CENTER, CENTER);
  text(displayedHour, 65, 0);

  pop();
}
